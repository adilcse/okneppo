---
alwaysApply: true
---

# General App Instructions

This document contains general development guidelines and instructions for the Okneppo application.

## Development Environment

### Node.js Version
- **Always use Node.js version 22.15** when running terminal commands
- Use `nvm use 22.15` before executing any npm/pnpm commands
- This ensures consistency across development environments

### Package Manager
- **Use pnpm for all package installations** [[memory:4448758]]
- Prefer `pnpm install` over `npm install`
- Use `pnpm add <package>` for adding new dependencies
- Use `pnpm remove <package>` for removing dependencies

## API and Data Fetching

### Client-Side API Calls
- **Use React Query for all API calls from client-side** [[memory:4448756]]
- Implement proper loading states, error handling, and caching
- Use React Query hooks like `useQuery`, `useMutation`, `useInfiniteQuery`
- Configure proper query keys for cache invalidation

### Server-Side Rendering
- **Prefer generating HTML in Node.js server routes using string replace for templating** [[memory:4509286]]
- Avoid React components for server-side HTML generation when possible
- Use template strings and string replacement for dynamic content

## Database Operations

### Database Utility
- Use the custom `db` utility from `@/lib/db.ts` for all database operations
- Available methods: `findOne`, `find`, `count`, `create`, `upsert`, `update`, `destroy`, `query`
- Use `db.upsert` for handling conflicts (INSERT ... ON CONFLICT UPDATE)
- Always use parameterized queries to prevent SQL injection

### Database Schema
- Use PostgreSQL with Neon Database
- Tables are automatically created via `initializeTables()` function
- Include proper indexes for performance optimization
- Use `business_account_id` for multi-tenant data isolation

## Code Quality and Standards

### TypeScript
- Use TypeScript for all new code
- Define proper interfaces and types
- Avoid `any` types - use specific types or `unknown`
- Use proper type assertions when necessary

### Error Handling
- Implement proper error handling in all API routes
- Use try-catch blocks for async operations
- Return consistent error response formats
- Log errors with appropriate context

### Environment Variables
- Never hardcode API keys or sensitive data
- Use environment variables from `.env.local` file
- Never hallucinate API keys - always use populated values from `.env.local`
- Document required environment variables in setup guides

## UI/UX Guidelines

### Dark Mode Support
- Ensure all components work in both light and dark modes
- Use Tailwind CSS dark mode classes (`dark:bg-gray-800`, `dark:text-white`, etc.)
- Test components in both themes
- Use consistent color schemes across the application

### Component Structure
- Use reusable components from `@/components/common`
- Follow the existing component patterns
- Implement proper loading states and error boundaries
- Use consistent spacing and typography

## Security Best Practices

### Webhook Security
- Implement proper signature verification for webhooks
- Use HMAC verification for incoming webhook requests
- Validate all incoming data before processing
- Use environment variables for webhook secrets and tokens

### Data Validation
- Validate all user inputs on both client and server side
- Sanitize data before database operations
- Use proper authentication and authorization
- Implement rate limiting where appropriate

## File Organization

### Project Structure
- Follow the existing Next.js 13+ app directory structure
- Place API routes in `src/app/api/`
- Place page components in `src/app/(pages)/`
- Place reusable components in `src/components/`
- Place utilities and libraries in `src/lib/`

### Naming Conventions
- Use kebab-case for file names
- Use PascalCase for component names
- Use camelCase for function and variable names
- Use UPPERCASE for constants and environment variables

## Testing

### Test Structure
- Write tests for critical functionality
- Use Jest for unit testing
- Test both success and error scenarios
- Mock external API calls in tests

### Test Files
- Place test files in `src/__tests__/` directory
- Use `.test.tsx` or `.test.ts` extensions
- Follow the existing test patterns in the codebase

## Performance Optimization

### Database Queries
- Use proper indexing for frequently queried columns
- Optimize complex queries with CTEs (Common Table Expressions)
- Use pagination for large datasets
- Implement proper caching strategies

### Client-Side Performance
- Use React Query for efficient data fetching and caching
- Implement proper loading states to improve perceived performance
- Use lazy loading for heavy components
- Optimize images and assets

## Documentation

### Code Documentation
- Document complex business logic
- Use JSDoc comments for functions and classes
- Keep README files updated
- Document API endpoints and their usage

### Setup Documentation
- Create detailed setup guides for new features
- Document environment variable requirements
- Provide clear instructions for deployment
- Include troubleshooting sections

## Feature Development

### Feature Flags
- Use feature flags for new features when possible
- Store flag names in enums or const objects
- Use UPPERCASE_WITH_UNDERSCORE naming convention
- Gate flag-dependent code with proper validation

### Custom Properties
- Use enums or const objects for properties referenced in multiple files
- Maintain consistency in naming conventions
- Document any changes to existing property names

## Integration Guidelines

### WhatsApp Integration
- Use `business_account_id` for proper data isolation
- Implement proper webhook verification
- Handle message status updates correctly
- Use upsert operations for message storage

### Payment Integration
- Implement proper webhook handling for payment events
- Use secure payment processing
- Handle payment failures gracefully
- Maintain audit trails for transactions

## Deployment and Monitoring

### Environment Management
- Use different environment variables for different stages
- Implement proper logging for production
- Monitor application performance and errors
- Use proper error tracking and alerting

### Database Migrations
- Handle database schema changes carefully
- Use proper migration scripts when needed
- Test migrations on staging environment first
- Backup data before major schema changes

## Common Patterns

### API Response Format
```typescript
// Success response
{
  success: true,
  data: T,
  pagination?: {
    page: number,
    limit: number,
    total: number,
    totalPages: number
  }
}

// Error response
{
  success: false,
  error: string
}
```

### Error Handling Pattern
```typescript
try {
  // Operation
  const result = await someOperation();
  return NextResponse.json({ success: true, data: result });
} catch (error) {
  console.error('Operation failed:', error);
  return NextResponse.json(
    { success: false, error: 'Operation failed' },
    { status: 500 }
  );
}
```

### React Query Pattern
```typescript
const { data, isLoading, error } = useQuery({
  queryKey: ['resource', id],
  queryFn: () => fetchResource(id),
  enabled: !!id
});
```


## Data Tables and Grids

### DataGrid Component Usage
- **ALWAYS use the DataGrid component for any table or data display** in the application
- The DataGrid component is located at `@/components/common/DataGrid`
- Provides consistent table functionality across the entire application
- Includes built-in sorting, pagination, search, and loading states

### DataGrid Features
- **Sorting**: Click column headers to sort data (ascending/descending)
- **Pagination**: Built-in pagination with page size selector
- **Search**: Real-time search functionality
- **Loading States**: Proper loading, error, and empty states
- **Row Interactions**: Click handlers for row selection
- **Responsive Design**: Mobile-friendly with dark mode support
- **TypeScript**: Full type safety with generics

### DataGrid Implementation Pattern
```typescript
import DataGrid, { ColumnDef } from '@/components/common/DataGrid';

// Define your data type
interface MyDataType {
  id: number;
  name: string;
  email: string;
  status: 'active' | 'inactive';
}

// Define columns
const columns: ColumnDef<MyDataType>[] = [
  {
    key: 'name',
    label: 'Name',
    sortable: true,
    render: (item: MyDataType) => (
      <span className="font-medium">{item.name}</span>
    )
  },
  {
    key: 'email',
    label: 'Email',
    sortable: true
  },
  {
    key: 'status',
    label: 'Status',
    sortable: true,
    render: (item: MyDataType) => (
      <span className={`px-2 py-1 rounded-full text-xs ${
        item.status === 'active' 
          ? 'bg-green-100 text-green-800' 
          : 'bg-red-100 text-red-800'
      }`}>
        {item.status}
      </span>
    )
  }
];

// Use in component
<DataGrid
  data={data}
  columns={columns}
  pagination={pagination}
  loading={loading}
  error={error?.message}
  
  // Sorting
  sortBy={sortBy}
  sortOrder={sortOrder}
  onSort={handleSort}
  
  // Pagination
  onPageChange={handlePageChange}
  onPageSizeChange={handlePageSizeChange}
  
  // Search
  searchTerm={searchTerm}
  onSearchChange={handleSearch}
  searchPlaceholder="Search by name or email..."
  
  // Row interactions
  onRowClick={handleRowClick}
  
  // Customization
  title="My Data Table"
  showSearch={true}
  showPageSizeSelector={true}
/>
```

### DataGrid API Requirements
When implementing DataGrid with backend data, ensure your API supports:
- **Sorting**: `sortBy` and `sortOrder` query parameters
- **Pagination**: `page` and `limit` query parameters
- **Search**: `search` query parameter for filtering
- **Response Format**: Consistent pagination info in response

### DataGrid Column Configuration
- **key**: Database field name for sorting and data access
- **label**: Display text for column header
- **sortable**: Boolean to enable/disable sorting
- **render**: Custom render function for complex cell content
- **className**: Custom CSS classes for cells
- **headerClassName**: Custom CSS classes for header

### DataGrid Best Practices
- Always define proper TypeScript interfaces for your data
- Use custom render functions for complex cell content (badges, buttons, etc.)
- Implement proper loading and error states
- Use consistent styling with the application theme
- Test both light and dark modes
- Ensure mobile responsiveness

### When NOT to Use DataGrid
- Simple static tables with no sorting/pagination needs
- Tables with complex nested structures that don't fit the column model
- Tables that require custom table layouts not supported by the component

## Troubleshooting

### Common Issues
- Ensure Node.js version 22.15 is being used
- Check environment variables are properly set
- Verify database connections and permissions
- Check webhook endpoints are accessible

### Debugging
- Use console.log for debugging (remove in production)
- Check browser developer tools for client-side issues
- Monitor server logs for backend issues
- Use database query logging for SQL debugging

---

**Last Updated**: January 2025
**Version**: 1.0# General App Instructions

This document contains general development guidelines and instructions for the Okneppo application.

## Development Environment

### Node.js Version
- **Always use Node.js version 22.15** when running terminal commands
- Use `nvm use 22.15` before executing any npm/pnpm commands
- This ensures consistency across development environments

### Package Manager
- **Use pnpm for all package installations** [[memory:4448758]]
- Prefer `pnpm install` over `npm install`
- Use `pnpm add <package>` for adding new dependencies
- Use `pnpm remove <package>` for removing dependencies

## API and Data Fetching

### Client-Side API Calls
- **Use React Query for all API calls from client-side** [[memory:4448756]]
- Implement proper loading states, error handling, and caching
- Use React Query hooks like `useQuery`, `useMutation`, `useInfiniteQuery`
- Configure proper query keys for cache invalidation

### Server-Side Rendering
- **Prefer generating HTML in Node.js server routes using string replace for templating** [[memory:4509286]]
- Avoid React components for server-side HTML generation when possible
- Use template strings and string replacement for dynamic content

## Database Operations

### Database Utility
- Use the custom `db` utility from `@/lib/db.ts` for all database operations
- Available methods: `findOne`, `find`, `count`, `create`, `upsert`, `update`, `destroy`, `query`
- Use `db.upsert` for handling conflicts (INSERT ... ON CONFLICT UPDATE)
- Always use parameterized queries to prevent SQL injection

### Database Schema
- Use PostgreSQL with Neon Database
- Tables are automatically created via `initializeTables()` function
- Include proper indexes for performance optimization
- Use `business_account_id` for multi-tenant data isolation

## Code Quality and Standards

### TypeScript
- Use TypeScript for all new code
- Define proper interfaces and types
- Avoid `any` types - use specific types or `unknown`
- Use proper type assertions when necessary

### Error Handling
- Implement proper error handling in all API routes
- Use try-catch blocks for async operations
- Return consistent error response formats
- Log errors with appropriate context

### Environment Variables
- Never hardcode API keys or sensitive data
- Use environment variables from `.env.local` file
- Never hallucinate API keys - always use populated values from `.env.local`
- Document required environment variables in setup guides

## UI/UX Guidelines

### Dark Mode Support
- Ensure all components work in both light and dark modes
- Use Tailwind CSS dark mode classes (`dark:bg-gray-800`, `dark:text-white`, etc.)
- Test components in both themes
- Use consistent color schemes across the application

### Component Structure
- Use reusable components from `@/components/common`
- Follow the existing component patterns
- Implement proper loading states and error boundaries
- Use consistent spacing and typography

## Security Best Practices

### Webhook Security
- Implement proper signature verification for webhooks
- Use HMAC verification for incoming webhook requests
- Validate all incoming data before processing
- Use environment variables for webhook secrets and tokens

### Data Validation
- Validate all user inputs on both client and server side
- Sanitize data before database operations
- Use proper authentication and authorization
- Implement rate limiting where appropriate

## File Organization

### Project Structure
- Follow the existing Next.js 13+ app directory structure
- Place API routes in `src/app/api/`
- Place page components in `src/app/(pages)/`
- Place reusable components in `src/components/`
- Place utilities and libraries in `src/lib/`

### Naming Conventions
- Use kebab-case for file names
- Use PascalCase for component names
- Use camelCase for function and variable names
- Use UPPERCASE for constants and environment variables

## Testing

### Test Structure
- Write tests for critical functionality
- Use Jest for unit testing
- Test both success and error scenarios
- Mock external API calls in tests

### Test Files
- Place test files in `src/__tests__/` directory
- Use `.test.tsx` or `.test.ts` extensions
- Follow the existing test patterns in the codebase

## Performance Optimization

### Database Queries
- Use proper indexing for frequently queried columns
- Optimize complex queries with CTEs (Common Table Expressions)
- Use pagination for large datasets
- Implement proper caching strategies

### Client-Side Performance
- Use React Query for efficient data fetching and caching
- Implement proper loading states to improve perceived performance
- Use lazy loading for heavy components
- Optimize images and assets

## Documentation

### Code Documentation
- Document complex business logic
- Use JSDoc comments for functions and classes
- Keep README files updated
- Document API endpoints and their usage

### Setup Documentation
- Create detailed setup guides for new features
- Document environment variable requirements
- Provide clear instructions for deployment
- Include troubleshooting sections

## Feature Development

### Feature Flags
- Use feature flags for new features when possible
- Store flag names in enums or const objects
- Use UPPERCASE_WITH_UNDERSCORE naming convention
- Gate flag-dependent code with proper validation

### Custom Properties
- Use enums or const objects for properties referenced in multiple files
- Maintain consistency in naming conventions
- Document any changes to existing property names

## Integration Guidelines

### WhatsApp Integration
- Use `business_account_id` for proper data isolation
- Implement proper webhook verification
- Handle message status updates correctly
- Use upsert operations for message storage

### Payment Integration
- Implement proper webhook handling for payment events
- Use secure payment processing
- Handle payment failures gracefully
- Maintain audit trails for transactions

## Deployment and Monitoring

### Environment Management
- Use different environment variables for different stages
- Implement proper logging for production
- Monitor application performance and errors
- Use proper error tracking and alerting

### Database Migrations
- Handle database schema changes carefully
- Use proper migration scripts when needed
- Test migrations on staging environment first
- Backup data before major schema changes

## Common Patterns

### API Response Format
```typescript
// Success response
{
  success: true,
  data: T,
  pagination?: {
    page: number,
    limit: number,
    total: number,
    totalPages: number
  }
}

// Error response
{
  success: false,
  error: string
}
```

### Error Handling Pattern
```typescript
try {
  // Operation
  const result = await someOperation();
  return NextResponse.json({ success: true, data: result });
} catch (error) {
  console.error('Operation failed:', error);
  return NextResponse.json(
    { success: false, error: 'Operation failed' },
    { status: 500 }
  );
}
```

### React Query Pattern
```typescript
const { data, isLoading, error } = useQuery({
  queryKey: ['resource', id],
  queryFn: () => fetchResource(id),
  enabled: !!id
});
```

## Troubleshooting

### Common Issues
- Ensure Node.js version 22.15 is being used
- Check environment variables are properly set
- Verify database connections and permissions
- Check webhook endpoints are accessible

### Debugging
- Use console.log for debugging (remove in production)
- Check browser developer tools for client-side issues
- Monitor server logs for backend issues
- Use database query logging for SQL debugging

---

**Last Updated**: January 2025
**Version**: 1.0